边栏插件开发指南

介绍

边栏插件是多维表格推出的⼀个灵活、便捷的开放能⼒。开发者可通过编程来实现⾃定义功能，扩展

核⼼平台能⼒，构建更强⼤的业务系统，或将其发布到插件中⼼以供所有多维表格⽤⼾使⽤。

寻求帮助

如果在开发过程中遇到任何困难，或有任何反馈，请加⼊交流群，发起话题，与运营⼈员及其他开发

者⼀起进⾏讨论。

多维表格插件交流群 外部

如果你有特殊的需求⼜没有开发资源，可以向其他开发者提交插件需求，开发者也可以查看需求汇总

来认领需求。

开始开发

群名⽚跟随⽰例，尝试动⼿完成⼀个插件的搭建，对插件的开发流程建⽴直观认知。⽆论是Vercel、

Github、localhost，还是你⾃⼰的服务器，只要部署了服务，插件都可以在多维表格中正常运⾏。你

可以直接在多维表格的控制台中查看调试信息。

• 新建或打开任意多维表格，点击 插件 展开插件⾯板

• 点击 ⾃定义插件 ，点击 +新增插件 ，在输⼊框内填⼊运⾏地址后点击 确定 添加并运⾏插件

多维表格数据模型

我们先了解⼀下多维表格的核⼼概念以及相关知识，多维表格的数据结构与常⻅的关系型数据库基本

概念相通。下图所⽰的是API的设计模型:

 AI编程实践：多维表格插件 

写了⼀份「AI友好」的多维表格插件教程，主要提供了Markdown格式的资源，包括API、开发指

南、设计规范等等，⽅便AI读取和参考。

⼀个简单的从0编写字段捷径教程，作为演⽰。

实现⼀个前端插件

以BaseJSSDK为例，演⽰如何开发⼀个前端插件。

准备开发环境

安装SDK，或选择⼀个模板项⽬GitHub地址，Fork此仓库并clone到本地，再按照Readme.md中

说明运⾏项⽬

npm

1

npm i -S @lark-base-open/node-sdk

yarn

1

yarn add @lark-base-open/node-sdk

实现逻辑

在准备好开发环境的基础上，我们来开发⼀个货币转换插件，⾸先需要⽤⼾先插⼊⼀个货币字段，并

填充⼀定的数据。

1. 安装完成之后，在src⽬录下新建ts⽂件取名为 exchange-api.ts 并复制以下内容。

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

import axios from 'axios';

interface ExchangeRatesResponse {

  rates: {

    [key: string]: number;

  };

  base: string;

  date: string;

}

export async function getExchangeRate(base: string, target: string): 

Promise<number | undefined> {

  try {

    const response = await axios.get<ExchangeRatesResponse>

(`https://api.exchangerate-api.com/v4/latest/${base}`);

    const rate = response.data.rates[target];

    if (!rate) {

      throw new Error(`Exchange rate not found for target currency: 

${target}`);

    }

    return rate;

  } catch (error) {

    console.info(`Error fetching exchange rate: ${(error as 

any).message}`);

23

24

  }

}

这部分的代码逻辑是获取实时汇率， base 指的是当前的货币类型 target 指的是兑换的货币
类型，通过这个API可以获取保留两位⼩数的汇率。

2. 在src⽬录下新建⼀个ts⽂件，取名为 const.ts ，并将以下内容复制进去。

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

import { CurrencyCode } from '@lark-base-open/js-sdk';

export const CURRENCY = [

  { label: 'CNY', value: CurrencyCode.CNY },

  { label: 'USD', value: CurrencyCode.USD },

  { label: 'EUR', value: CurrencyCode.EUR },

  { label: 'AED', value: CurrencyCode.AED },

  { label: 'BRL', value: CurrencyCode.BRL },

  { label: 'CAD', value: CurrencyCode.CAD },

  { label: 'CHF', value: CurrencyCode.CHF },

  { label: 'HKD', value: CurrencyCode.HKD },

  { label: 'INR', value: CurrencyCode.INR },

  { label: 'JPY', value: CurrencyCode.JPY },

  { label: 'MXN', value: CurrencyCode.MXN },

];

这个⽂件是⽤来枚举可以进⾏转换的货币类型，因为只做Demo展⽰，所以枚举的数量有限。

3. 提供⽤⼾选择转换的货币字段能⼒。

⾸先，货币转换是在原本的字段进⾏货币值的转换，所以我们需要筛选当前 table 中的货币类
型字段，来让⽤⼾进⾏选择，这⾥我们在交互上使⽤ Select 组件来实现选择这个动作，其中每
⼀个选项都是当前 table 可以选择的货币字段。

我们修改 index.tsx 中的 LoadApp 函数：

定义货币字段信息的 currencyFieldMetaList 以及选择进⾏转换的字段
selectFieldId 和选择转换的货币类型 currency 。

1

2

3

4

import { bitable, CurrencyCode, FieldType, ICurrencyField, 

ICurrencyFieldMeta } from '@lark-base-open/js-sdk'; 

import { CURRENCY } from './const'; 

function LoadApp() {

5

6

7

  const [currencyFieldMetaList, setMetaList] = 

useState<ICurrencyFieldMeta[]>([]) 

  const [selectFieldId, setSelectFieldId] = useState<string>(); 

  const [currency, setCurrency] = useState<CurrencyCode>(); 

修改 useEffect 函数，在⻚⾯完成渲染时获取当前 table 内的货币类型字段信息。

1

2

3

4

5

6

7

8

useEffect(() => {

  const fn = async () => {

    const table = await bitable.base.getActiveTable();

    const fieldMetaList = await 

table.getFieldMetaListByType<ICurrencyFieldMeta>(FieldType.Currency); 

    setMetaList(fieldMetaList); 

  };

  fn();

}, []);

按照顺序，我这⾥讲解⼀下⽤到的相关API：

◦

◦

bitable.base.getActiveTable :获取当前的 table ，获取到了 table 之后就可以
对数据进⾏操作

table.getFieldMetaListByType<ICurrencyFieldMeta>
(FieldType.Currency) :通过字段类型去获取对应的字段信息

然后我们修改渲染的组件，满⾜⽤⼾交互上的需求。

1

2

3

4

5

6

7

8

9

10

11

12

13

14

const formatFieldMetaList = (metaList: ICurrencyFieldMeta[]) => { 

  return metaList.map(meta => ({ label: meta.name, value: meta.id })); 

}; 

return <div>

  <div style={{ margin: 10 }}> 

    <div>Select Field</div> 

    <Select style={{ width: 120 }} onSelect={setSelectFieldId} options=

{formatFieldMetaList(currencyFieldMetaList)}/> 

  </div> 

  <div style={{ margin: 10 }}>

    <div>Select Currency</div>

    <Select options={CURRENCY} style={{ width: 120 }} onSelect=

{setCurrency}/>

  </div>

</div>

这个时候，⽤⼾已经可以选择字段和想要转换的货币类型了，我们接下来实现转换货币值的逻辑。

4. 实现货币转换的逻辑，我们先将获取汇率的API引⼊。

1

2

import { CURRENCY } from './const';

import { getExchangeRate } from './exchange-api'; 

然后准备⼀个转换交互按钮以及转换函数。

1

2

3

4

5

6

7

8

9

10

11

const transform = async () => { 

}

return <div>

  <div style={{ margin: 10 }}>

    <div>Select Field</div>

    <Select style={{ width: 120 }} onSelect={setSelectFieldId} options=

{formatFieldMetaList(currencyFieldMetaList)}/>

  </div>

  <div style={{ margin: 10 }}>

    <div>Select Currency</div>

    <Select options={CURRENCY} style={{ width: 120 }} onSelect=

{setCurrency}/>

12

    <Button style={{ marginLeft: 10 }} onClick=

{transform}>transform</Button>

13

  </div>

接下来实现我们最重要的⼀步：在 transform 函数中实现货币字段的货币类型转换以及数值转
换。

1

2

3

4

5

6

7

8

9

const transform = async () => {
  // 如果⽤⼾没有选择货币或者转换的字段，则不进⾏转换操作 
  if (!selectFieldId || !currency) return;

  const table = await bitable.base.getActiveTable();
  // 获取货币字段，这⾥我们传⼊了⼀个 ICurrencyField  
  // 来表明我们获取的是⼀个货币类型的字段   
  // 在使⽤ ts 的情况下，我们限制了这个字段的类型之后  
  // 在开发时就会获得很多类型提⽰，来帮我们进⾏开发   
  const currencyField = await table.getField<ICurrencyField>

(selectFieldId); 

10

11

  const currentCurrency = await currencyField.getCurrencyCode();
  // 设置货币类型 

12

13

14

15

16

17

18

19

20

21

22

23

24

25

  await currencyField.setCurrencyCode(currency);
  // 获取货币的汇率 
  const ratio = await getExchangeRate(currentCurrency, currency);

  if (!ratio) return;
  // ⾸先我们获取 recordId  
  const recordIdList = await table.getRecordIdList();
  // 对 record 进⾏遍历 
  for (const recordId of recordIdList) {
    // 获取当前的货币值 
    const currentVal = await currencyField.getValue(recordId);
    // 通过汇率进⾏新值的运算 
    await currencyField.setValue(recordId, currentVal * ratio);

  }

}

在上⾯的例⼦中，我们在获取字段时传⼊了对其类型的限制，从⽽在后续的逻辑中得到了⾜够的类

型提⽰，这⼀步⾮常重要，我们⾮常推荐开发者⽤类似的⽅法来获取字段，从⽽提⾼开发体验。

在修改货币类型时，可以直接调⽤ CurrencyField.setCurrencyCode 来改变对应的货币类
型，这也是得益于在获取对应的字段时我们提供了类型（在这个基础上，需要修改单选/多选字段

的选项时，也可以做到类似的效果）。

在设置货币值的时候，我们⽤ CurrencyField.getValue 来获取对应的数据，然后进⾏运
算，回填的时候，也是调⽤了 CurrencyField.setValue ，我们⾮常推荐开发者在对值进⾏
增删改查的时候从字段⼊⼿，我们细化了⾮常多的字段类型，从⽽优化开发者的使⽤体验（例如附

件字段，在setValue时⽀持直接传⼊⽂件，来达到设置对应值的⽬的）。

货币转换插件完整代码地址

实现⼀个服务端插件（上架需⾃备服务）

以BaseNode.jsSDK为例，演⽰如何开发⼀个服务端插件。

准备开发环境

安装SDK

npm

1

npm i -S @lark-base-open/node-sdk

yarn

1

yarn add @lark-base-open/node-sdk

实现逻辑

在准备好开发环境的基础上，我们来开发⼀个批量查找替换插件。

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

31

32

import { BaseClient } from '@lark-base-open/node-sdk';

// 新建 BaseClient，填写需要操作的 appToken 和 personalBaseToken 
const client = new BaseClient({

  appToken: 'xxx',

  personalBaseToken: 'xxx'

});

const TABLEID = 'xxx';

interface IRecord {

  record_id: string;

  fields: Record<string, any>

}

// 查找替换 
async function searchAndReplace(from: string, to: string) {
  // 获取当前表的字段信息 
  const res = await client.base.appTableField.list({

    params: {

      page_size: 100,

    },

    path: {

      table_id: TABLEID,

    }

  });

  const fields = res?.data?.items || [];
  // ⽂本列 
  const textFieldNames = fields.filter(field => field.ui_type === 

'Text').map(field => field.field_name);

  // 遍历记录 
  for await (const data of await 

client.base.appTableRecord.listWithIterator({ params: { page_size: 50 }, 

path: { table_id: TABLEID } })) {

33

    const records = data?.items || [];

34

35

36

37

38

39

40

41

42

43

44

45

46

47

48

49

50

51

52

53

54

55

56

57

58

59

60

61

62

63

64

65

66

67

68

69

    const newRecords: IRecord[] = [];

    for (const record of records) {

      const { record_id, fields } = record || {};

      const entries = Object.entries<string>(fields);

      const newFields: Record<string, string> = {};

      for (const [key, value] of entries) {
        // 替换多⾏⽂本字段值 
        if ((textFieldNames.includes(key)) && value) {

          const newValue = value.replace(new RegExp(from, 'g'), to);
          // 把需要替换的字段加⼊ newFields 
          newValue !== value && (newFields[key] = newValue);

        }

      }
      // 需要替换的记录加⼊ newRecords 
      Object.keys(newFields).length && newRecords.push({

        record_id,

        fields: newFields,

      })

    }

    // 批量更新记录 
    await client.base.appTableRecord.batchUpdate({

      path: {

        table_id: TABLEID,

      },

      data: {

        records: newRecords

      }

    })

  }

  console.log('success')

}

searchAndReplace('abc', '23333333');

console.log('start')

SDK

我们提供了多个语⾔版本的SDK，将所有冗⻓的接⼝逻辑内置处理，提供完备的类型系统、语义化的

编程接⼝，提⾼开发者的编码体验。根据的业务场景选择适合的技术栈和插件运⾏形态，纯前端项⽬

偏重通过界⾯交互实现对多维表格的数据操作，服务端插件具有脱离界⾯的运⾏能⼒，可兼顾部分⾃

动化功能，或是两者结合。

前端SDK

• BaseJSSDK

服务端SDK

• BaseNode.jsSDK

• BasePythonSDK

• BaseGolangSDK

鉴权

前端插件

前端插件运⾏时将获取当前登录的⽤⼾⾝份，插件的权限范围与登录⽤⼾权限范围⼀致。

服务端插件

针对多维表格服务端SDK，我们制定了独⽴的鉴权体系，获取和使⽤更为⽅便。开发者只需在⽹⻚端
获取多维表格对应的授权码 PersonalBaseToken ，即可在服务端通过SDK操作多维表格数据。

⽤⼾

Base⽹⻚

BaseOpenAPI

BaseDB

视图

⽣成PersonalBaseToken

返回PersonalBaseToken

使⽤PersonalBaseToken调⽤OpenAPI

读写Base数据

• 多维表格的所有者/管理员有权限获取

• 通过授权码可以读写对应多维表格的数据，请勿公开传播

• 通过授权码调⽤服务端接⼝操作多维表格数据时，权限范围与授权码的⽣成者⼀致

• 授权码仅可操作对应的多维表格，每个多维表格的授权码需要独⽴⽣成和使⽤，互不影响

• 授权码默认永久有效，除⾮在多维表格⽹⻚端⼿动关闭或更新

获取授权码

使⽤授权码

多维表格在新域名独⽴部署了⼀套Base业务的OpenAPI，接⼝路径、接⼝定义和⻜书开放平台完全

⼀致，没有额外的学习成本，授权码仅能操作Base相关的开放接⼝。

• 云⽂档-多维表格（Base）：全部接⼝

• 云⽂档-云空间（Drive）：上传素材、下载素材两个接⼝

以「列出记录」接⼝为例：

协议和⽅法

HTTPGET

域名

https://base-api.feishu.cn

与OpenAPI不

https://base-api.larksuite.com

同

Path和Seesion API路径：/open-apis/bitable/v1/apps/:app_token/tables/:table_id/records

Header

Authorization:Bearer[PersonalBaseToken]

QueryParam

Response

1

2

3

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

filter:CurrentValue.[多⾏⽂本]="双向关联测试"
sort:"["字段1 DESC"]"
page_size:20

{

    "code": 0,

    "data": {

        "has_more": true,

        "items": [

            {

                "fields": {
                    "其他表": [
                        {

                            "record_ids": [

                                "rec2ltnYkQ",

                                "recZE5zqYP"

                            ],

                            "table_id": "tblvC2gefQet5bTV",
                            "text": "测试,测试2",
                            "text_arr": [
                                "测试",
                                "测试2"
                            ],

                            "type": "text"

                        }

                    ],

                },

25

26

27

28

29

30

31

32

33

                "id": "rec0iAsbhD",

                "record_id": "rec0iAsbhD"

            }

        ],

        "page_token": "rec0iAsbhD",

        "total": 9

    },

    "msg": "success"

}

UIbuilder

UIbuilder将复杂的UI渲染简化成⼀⾏命令调⽤的渲染框架，以降低UI搭建成本。⽀持通过SDK引
⽤，或直接ForkUIBuilderTemplate（github地址），然后在 src/runUIBuilder.tsx ⽂件
的 main 函数内调⽤ UIBuilder 的⽅法。详细使⽤⽅法可通过UIBuilder模板使⽤指南了解。

使⽤模板

我们在https://replit.com（可选，或者直接clonegithub上模板（⻅下⽂中的“模板”）即可）中提

供了⼀系列的模板帮助你快速开发，请根据你的业务场景和技术栈，选择对应的模板Fork到你的

Replit账号内，或导⼊GitHub进⾏开发。

前端插件模板

• 如果你准备开发表单UI，或者你是⾮前端开发同学，想降低UI搭建成本，建议使⽤以下模板：

a. UIBuilder模板，github地址⼊⼝为 src/runUIBuilder.tsx ⽂件，具体使⽤⽅法⻅

UIBuilder模板使⽤指南 

• 如果你有前端开发经验则可以使⽤以下模板来⾃由搭建UI：

a. HTML模板，github地址⼊⼝为 src/index.ts ⽂件

b. React模板，github地址⼊⼝为 src/App.tsx ⽂件

c. Vue模板，github地址⼊⼝为 src/App.vue ⽂件

服务端插件模板

• Nodejs模板

• Python模板

前后端混合插件模板

nextjs⽆法静态部署，如需官⽅部署，请优先使⽤其他的模板。

1. Nextjs模板，前端⼊⼝为 pages/index.tsx ⽂件，服务端⼊⼝为 pages/api ⽬录下的⽂件

参考项⽬

由其他开发者提交并同意开发源代码的项⽬被集中整合，开发者可通过查看参考项⽬，阅读源代码来

寻找灵感。

合法域名

我们没有对域名进⾏限制，只要是HTTPS协议连接都可以正常运⾏。如果出于安全合规⽅⾯原因希望

限制某些特定域名的访问，可以填写申请表单将指定域名加为⿊名单。

发布到插件中⼼

完成插件开发后，你可以将其 发布到插件中⼼ ，以供所有多维表格⽤⼾使⽤。插件发布到插件中⼼

后，将由官⽅托管部署。在此之前你需要对插件的基本信息进⾏补充，我们对每个元素的价值及要求

进⾏了说明，并提供了⽰例，以帮助你顺利完成发布前的准备。

发布表单： 发布到插件中⼼

Checklist

只要提交⼀下信息就可以将插件发布到市场，但更加完善的信息有助于插件被更多⽤⼾使⽤。

• 插件名

• 项⽬代码地址

• 简短描述

• 类别

• 使⽤录屏

简短描述

⽤⼾在浏览插件中⼼时会看到卡⽚上的简短描述，使⽤尽可能精简的语句描述该插件的功能及价值。

推荐使⽤主动动词（如添加、实施、创建、更新、可视化等）撰写基于动作的描述。

• 必要项

• 最多X个字符

• ⽰例：按照⼀定条件查找重复的记录，并删除它们。

详细介绍

在插件介绍⻚展⽰，它应该具体阐释插件的功能，通过步骤介绍如何使⽤插件，以及出现使⽤问题时

该如何寻求帮助，确保⽤⼾对插件有完整的了解。

• ⾮必要项，如开发者⽆法提供，我们的运营⼈员将通过AI为其⽣成

• 200⾄2,000个字符

• 建议使⽤换⾏符或项⽬符号列表令版式更为美观

• ⽀持通过Markdown编辑器⽣成Markdown语句

我们建议遵循此结构：

第1段：突出显⽰插件的主要功能、解决的问题以及核⼼优势，确保⽤⼾仅⽤⼀段⽂字就能理解插件

的功能。

第2段：分享更多⽤例并提供有关插件的更多背景信息。

第3段：提供⼀个⽤⼾可以寻求帮助的路径，例如帮助⽂档链接或联系⽅式。

类别

插件中⼼允许⽤⼾根据类别筛选插件，从以下列表中选择插件所属的类别：

• 必要项

• 最多选择三个

批量处理

内容转换

提取解析

附件处理

⽂本处理

开发⼯具

筛选查询

表结构处理

图表

导⼊导出

AI

翻译

营销

⼈事⾏政

进销存

设计⼯具

如果没找到适合的分类可通过交流群向我们反馈。

图标

使⽤图形语⾔尽可能的传达插件功能，避免出现复杂细节影响可识别性，并确保不存在版权⻛险，我

们提供了remixicon和iconpark两套开源图标库可供使⽤。你可以使⽤此模板创建⾃⼰的图标，选

择图标背景与元素的颜⾊搭配，并调整元素⼤⼩保持在框架内。

• 必要项，如开发者⽆法提供，将由我们的运营⼈员代为⽣成

• 推荐SVG格式

• 或128像素x128像素JPG/PNG

⾊板

介绍图⽚

通过若⼲静态图⽚来突出插件的主要特征、界⾯、品牌和标识。这些图⽚应将裁剪后的、重点突出的

界⾯与简短⽂字说明结合起来。

• ⾮必要项

• 宽⾼⽐例必须与图⽚/其他视频⼀致

• 推荐SVG格式

• 或1920像素x960像素JPG/PNG

在视觉上突出插件的功能和特性，⽽不是简单地截图。建议使⽤彩⾊背景，以确保图像在所有主题

（包括深⾊模式）中脱颖⽽出。每张图⽚都应侧重于介绍插件的⼀个功能点，使⽤⼾感受到价值。

介绍视频

使⽤此视频演⽰插件的特性、功能和⽤⼾界⾯，以帮助⽤⼾快速了解如何操作使⽤该插件。

• 必要项

• 宽⾼⽐例必须与图⽚/其他视频⼀致

• 宽⾼⽐例必须与图⽚/其他视频 致
• 不超过20秒

• MP4或GIF图

推荐使⽤桌⾯端即时消息截图⼯具，使⽤快捷键Alt+Shift+R（Windows）或Option+Shift+R

（Mac），框选录屏区域。或是⿏标悬浮于截图按钮，选择录屏，框选录屏区域，选择MP4或者

GIF格式，点击开始录制即可。

国际化

由于国际化和市场团队的要求，发布到市场的插件必须通过i18n能⼒⽀持中、⽇、英三种语⾔。请务

必使⽤插件i18njson翻译⼯具完成国际化，以确保专有名词的正确性。输⼊中⽂json，⼯具将翻译

并返回⽇、英两种语⾔的json结构。

⽰例：

./locales/zh.json

1

2

3

4

5

{
"label.username": "请输⼊⽤⼾名",
"label.password": "请输⼊密码",
...

}

./locales/en.json

1

2

3

4

5

{

"label.username": "Please enter your username",

"label.password": "Please enter your password",

...

}

./locales/jp.json

1

2

3

4

5

{
"label.username": "ユーザー名を⼊⼒してください",
"label.password": "パスワードを⼊⼒してください",
...

}

./i18n.ts

1

2

3

4

5

6

7

8

9

10

11

import i18n from 'i18next';

import { initReactI18next } from 'react-i18next';

import translationEN from './locales/en.json';

import translationZH from './locales/zh.json';

import translationZH from './locales/jp.json';

// 设置⽀持的语⾔列表 
const supportedLanguages = ['en', 'zh','jp'];

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

30

export function initI18n(lang:'en'|'zh'|'jp'){
  // 初始化 i18n 
i18n.use(initReactI18next).init({

  resources: {

    en: {

      translation: translationEN,

    },

    zh: {

      translation: translationZH,

    },

  },
  lng: lang, // 设置默认语⾔ 
  fallbackLng: 'en', // 如果没有对应的语⾔⽂件，则使⽤默认语⾔ 
  interpolation: {
    escapeValue: false, // 不进⾏ HTML 转义 
  },

});

}

UI&交互

出于视觉⼀致性考虑，对于主要由表单按钮等简单ui组成的插件，我们强烈建议开发者使⽤UIBuilDer

来搭建，如⽆法满⾜插件功能⽽需要⾃定义样式，也应符合基础的设计规范，确保插件的视觉质量。

在插件审核时，我们会确保⼀些基础的设计规范符合标准，如果想进⼀步提⾼插件的品质，可以参阅

Base开放设计规范。

🌅 如果你使⽤AI编程，强烈推荐将以下「Base开放设计规范」给到AI作为参考，以保证前端

UI的美观性和⼀致性。

• AI编程⼯具推荐：https://trae.ai、https://www.trae.com.cn、

https://www.cursor.com

Base开放设计规范.zip
12.68MB

布局

由于侧边栏插件运⾏⾯板可拖拽改变宽度，因此我们建议采⽤垂直布局，以保证⼩宽度情况下的可⽤

性。并在不同功能区及⻚⾯元素之间留有适当的间距。

⾃适应

在CSS样式处理上，应当注意使⽤动态单位及合理的对⻬，确保⻚⾯元素在不同⾯板宽度下保持良好

的⾃适应。侧边栏插件运⾏⾯板最⼩宽度为410px，最⼤宽度是根据⻚⾯宽度动态计算得出，最⼤宽

度=⻚⾯宽度-左侧侧边栏宽度-640px。

字体

优先使⽤系统默认的界⾯字体，同时提供⼀套备⽤字体库，来维护在不同平台以及浏览器的显⽰下，

字体始终保持良好的易读性和可读性，建议开发者同样使⽤这套字体规则以保证兼容性。

1

//中英⽂环境

2

font-family:-apple-system,BlinkMacSystemFont,Helvetica Neue,Tahoma,PingFang 

SC,Microsoft Yahei,Arial,Hiragino Sans GB,sans-serif,Apple Color Emoji,Segoe 

3

4

UI Emoji,Segoe UI Symbol,Noto Color Emoji;
//⽇⽂环境
font-family:"ヒラギノ⻆ゴ Pro W3", "Hiragino Kaku Gothic Pro", "Yu Gothic UI", 
"游ゴシック体", "Noto Sans Japanese",“Microsoft Jhenghei UI”,“Microsoft Yahei 
UI”,"ＭＳ Ｐゴシック", Arial, sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe 
UI Symbol,Noto Color Emoji;

主题⾊兼容

多维表格⽀持切换「浅⾊（lightmode）」和「深⾊（darkmode）」两种外观模式，因此插件在视

觉上也需要进⾏兼容。插件的iframe容器天然兼容两种主题⾊，因此开发者⽆需额外设置插件内元素
的背景⾊，只需要关注元素本⾝的颜⾊即可。开发者可以通过BaseJSSDK中的 getTheme 和
onThemeChange ⽅法来实现主题⾊切换。

获取当前主题 getTheme 

1

getTheme(): Promise<ThemeModeType>;

ThemeModeType 类型定义

1

2

3

4

1

2

⽰例

enum ThemeModeType {

  LIGHT = "LIGHT",

  DARK = "DARK"

}

const theme = await bitable.bridge.getTheme();

// 'LIGHT'

监听主题变化 onThemeChange 

1

onThemeChange(callback: (ev: IEventCbCtx<ThemeModeCtx>) => void): () => void;

⽰例

1

2

3

const theme = await bitable.bridge.onThemeChange((event) => {

  console.log('theme change', event.data.theme);

});

以Vue3+ElementPlus技术栈为例，封装⼀个hook，通过在App.vue中导⼊，实现整个插件的全局

使⽤

useTheme.ts

1

2

3

4

5

6

7

8

9

10

11

12

13

14

15

16

17

18

19

20

21

22

23

24

25

26

27

28

29

import { bitable } from '@lark-base-open/js-sdk';

export const useTheme = () => {

  const theme = ref('');

  const setThemeColor = () => {

    const el = document.documentElement;

// 处理主要样式 
    const themeStyles = {

      LIGHT: {

        '--el-color-primary': 'rgb(20, 86, 240)',

        '--el-bg-color': '#fff',

        '--el-border-color-lighter': '#dee0e3',

      },

      DARK: {

        '--el-color-primary': '#4571e1',

        '--el-bg-color': '#252525',

        '--el-border-color-lighter': '#434343',

      },

    };

    const currentThemeStyles = themeStyles[theme.value];

// 设置样式变量 
    Object.entries(currentThemeStyles).forEach(([property, value]) => {

      el.style.setProperty(property, value);

    });

  };

30

31

32

33

34

35

36

37

38

39

40

41

42

43

44

45

46

47

App.vue

1

2

3

4

5

6

7

8

9

10

11

12

13

// 挂载时处理 
  onMounted(async () => {

    theme.value = await bitable.bridge.getTheme();

    setThemeColor();

  });

// 主题修改时处理 
  bitable.bridge.onThemeChange((event) => {

    theme.value = event.data.theme;

    setThemeColor();

  });

// 抛出当前主题变量 
  return {

    theme

  };

};

<script setup>

  import Form from './components/Form.vue';

  import { useTheme } from '@/hooks/useTheme';

// 使⽤ useTheme hook 
  useTheme();

</script>

<template>

  <main>

    <Form />

  </main>

</template>

代码规范

在插件审核时，我们会对代码进⾏review，以规避在数据安全和性能等⽅⾯存在的隐患。

插件上架到多维表格的步骤

1. 本地打包

我们将直接静态部署前端产物，以避免⼆次构建打包，⾸先需要指定构建产物⽬录，⽐如指定部署

dist/index.html，

在 package.json 中设置 output 属性值为"dist"即可，注意需要同时去掉.gitignore⽂件中的
dist，并在每次代码更新之后重新打包构建⼀下，然后将重新构建( npm run build )的dist上传即
可。

代码块

1

2

3

{
  "output": "dist" // 指定直接上传 dist ⽬录了
}

同时需要注意的是，打包产物的资源引⽤路径不可以使⽤绝对路径，请使⽤相对路径，如在

vite.config.js中指定base:'./'：

代码块

import { defineConfig } from "vite";

export default defineConfig({
    base: "./", // 使⽤相对路径 
    //....

});

1

2

3

4

5

6

7

2. 禁⽌使⽤history路由，请使⽤hash路由

3. 填写共享表单

4. 多维表格审核通过后会Fork和部署你的项⽬初始化配置

插件运⾏时，需要基于插件功能遍历当前多维表格数据结构，进⾏初始化配置。如⽆法获取正确的数

据结构，或必须依赖选中单元格，则需给出明确提⽰，引导⽤⼾如何操作，避免产⽣疑惑。

通⽤的初始化配置逻辑

• 遍历所有表的所有字段类型

• 遍历所有表的记录数

• 选取符合字段类型要求且记录数最多的表

• 如对字段类型⽆严格限制，则直接判断记录数

• 如所有表都没有记录，则⽤第⼀个张表

• 按返回序列为插件配置项匹配适合的字段

监听事件

前端项⽬应当实时监听 base 、 table 、 view 、 field 、 record 、 cell 的数据变化，以
及选中状态变化。当上述维度发⽣改变时，插件应当即时响应，⽽⽆需⽤⼾⼿动刷新。

性能

在批量操作数据时，建议使⽤addRecords、setRecords、deleteRecords、getRecords等批量接⼝

来增删改查⾏记录，⽽不是使⽤单次接⼝循环遍历。

数据安全

为确保数据安全，除插件功能必要的API请求外，禁⽌将多维表格数据向外部发送。

常⻅问题

如何获取 appToken 
多维表格URL中如下图所⽰部分。（推荐使⽤「开发⼯具」插件获取）

❗ 注意URL路径必须是base/后⾯获取的才是正确的appToken，如果路径为wiki/则必须使

⽤「开发⼯具」插件获取。

如何获取 table_id 
多维表格URL中如下图所⽰部分（推荐使⽤「开发⼯具」插件获取）

如何获取 view_id 
多维表格URL中如下图所⽰部分（推荐使⽤「开发⼯具」插件获取）

边栏插件相关的参数

可在多维表格url后添加这些参数，以实现特定功能

1

2

3

4

5

6

7

8

9

10

11

12

隐藏侧边栏

hideSidebar=1

设置侧边栏展开宽度

extension_market_spread_width={number} 

打开插件市场

extension_market_spread=1

打开插件

extension_market_extension_id={id}
效果预览：Markdown

插件的部署和安全

 
 
 
多维表格插件由多维表格官⽅和第三⽅开发者提供，其中代码均由多维表格官⽅审核，部署在多维表

格官⽅服务器以及认证ISV的服务器上，以保证插件的安全合规。

插件权限

为了确保客⼾数据安全，插件权限是受限制的

1. 前端插件，接⼝的权限会跟随执⾏插件的⼈；（简⽽⾔之：如果该⽤⼾在多维表格界⾯上⽆权看某

些数据，那么插件中也看不到）

2. 服务端插件，插件运⾏依赖⽂档所有者提供PersonalBaseToken，这个权限等于「⽂档所有⼈」

的⾝份，但是必须由他/她亲⾃获取后提供

如何本地调试开发

你可以将fork出来的模板的node_modules删掉（如果不删掉就直接下载，可能会有点慢），然后将

代码下载到本地。

为了在本地运⾏代码，你需要安装nodejs以及vscode。

然后使⽤vscode打开下载的⽂件夹，然后新建终端，输⼊npmi并按回⻋；

安装完毕依赖包之后执⾏npmrundev，将本地起的localhost项⽬链接粘贴到插件的预览地址输⼊框

中，然后点击确定就可以看到本地预览的效果了。

如何将插件分享给其他⽤⼾

1. 在任意多维表格内访问插件详情，点击「复制链接」获取可分享的插件URL地址

2. 你可以将该地址分享给其他⽤⼾

https://bytedance.larkoffice.com/base/extension/replit_3c67c9577361a3e3

